import SwiftUI
import SwiftSyntax

/// Generated modifier enum for DigitalCrownRotationModifier modifiers.
/// Generated by ModifierSwift.
public enum DigitalCrownRotationModifier: Sendable {
    case digitalCrownRotationWithSwiftUICoreBindingVVVVStrideOptionalSwiftUIDigitalCrownRotationalSensitivitySwiftBoolSwiftBool(SwiftUICore.Binding<V>, from: V, through: V, by: V.Stride?, sensitivity: SwiftUI.DigitalCrownRotationalSensitivity, isContinuous: Swift.Bool, isHapticFeedbackEnabled: Swift.Bool)
    case digitalCrownRotationWithSwiftUICoreBindingV(SwiftUICore.Binding<V>)
    case digitalCrownRotationWithSwiftUICoreBindingVVVVStrideSwiftUIDigitalCrownRotationalSensitivitySwiftBoolSwiftBoolescapingSwiftUIDigitalCrownEventSwiftVoidescapingSwiftVoid(detent: SwiftUICore.Binding<V>, from: V, through: V, by: V.Stride, sensitivity: SwiftUI.DigitalCrownRotationalSensitivity, isContinuous: Swift.Bool, isHapticFeedbackEnabled: Swift.Bool, onChange: (SwiftUI.DigitalCrownEvent) -> Swift.Void, onIdle: () -> Swift.Void)
    case digitalCrownRotationWithSwiftUICoreBindingVVVVStrideSwiftUIDigitalCrownRotationalSensitivitySwiftBoolSwiftBoolescapingSwiftUIDigitalCrownEventSwiftVoidescapingSwiftVoid1(detent: SwiftUICore.Binding<V>, from: V, through: V, by: V.Stride, sensitivity: SwiftUI.DigitalCrownRotationalSensitivity, isContinuous: Swift.Bool, isHapticFeedbackEnabled: Swift.Bool, onChange: (SwiftUI.DigitalCrownEvent) -> Swift.Void, onIdle: () -> Swift.Void)
    case digitalCrownRotationWithSwiftUICoreBindingVVVSwiftUIDigitalCrownRotationalSensitivitySwiftBoolSwiftBoolescapingSwiftUIDigitalCrownEventSwiftVoidescapingSwiftVoid(SwiftUICore.Binding<V>, from: V, through: V, sensitivity: SwiftUI.DigitalCrownRotationalSensitivity, isContinuous: Swift.Bool, isHapticFeedbackEnabled: Swift.Bool, onChange: (SwiftUI.DigitalCrownEvent) -> Swift.Void, onIdle: () -> Swift.Void)
    case digitalCrownRotationWithSwiftUICoreBindingVescapingSwiftUIDigitalCrownEventSwiftVoidescapingSwiftVoid(SwiftUICore.Binding<V>, onChange: (SwiftUI.DigitalCrownEvent) -> Swift.Void, onIdle: () -> Swift.Void)
}

extension DigitalCrownRotationModifier: RuntimeViewModifier {
    public static var baseName: String { "digitalCrownRotation" }

    public init(syntax: FunctionCallExprSyntax) throws {
        if syntax.arguments.count == 1 {
            if let value0 = SwiftUICore.Binding<V>(syntax: (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil)!) {
                self = .digitalCrownRotationWithSwiftUICoreBindingV(value0)
                return
            }
        }
        if syntax.argument(named: "from") != nil || syntax.argument(named: "through") != nil || syntax.argument(named: "by") != nil || syntax.argument(named: "sensitivity") != nil || syntax.argument(named: "isContinuous") != nil || syntax.argument(named: "isHapticFeedbackEnabled") != nil {
            let value0: SwiftUICore.Binding<V> = (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil).flatMap { SwiftUICore.Binding<V>(syntax: $0) }
            let from: V = syntax.argument(named: "from")?.expression.flatMap { V(syntax: $0) }
            let through: V = syntax.argument(named: "through")?.expression.flatMap { V(syntax: $0) }
            let by: V.Stride? = syntax.argument(named: "by")?.expression.flatMap { V.Stride(syntax: $0) } ?? nil
            let sensitivity: SwiftUI.DigitalCrownRotationalSensitivity = syntax.argument(named: "sensitivity")?.expression.flatMap { SwiftUI.DigitalCrownRotationalSensitivity(syntax: $0) } ?? .high
            let isContinuous: Swift.Bool = syntax.argument(named: "isContinuous")?.expression.flatMap { Swift.Bool(syntax: $0) } ?? false
            let isHapticFeedbackEnabled: Swift.Bool = syntax.argument(named: "isHapticFeedbackEnabled")?.expression.flatMap { Swift.Bool(syntax: $0) } ?? true
            self = .digitalCrownRotationWithSwiftUICoreBindingVVVVStrideOptionalSwiftUIDigitalCrownRotationalSensitivitySwiftBoolSwiftBool(value0, from: from, through: through, by: by, sensitivity: sensitivity, isContinuous: isContinuous, isHapticFeedbackEnabled: isHapticFeedbackEnabled)
            return
        }
        if syntax.argument(named: "detent") != nil || syntax.argument(named: "from") != nil || syntax.argument(named: "through") != nil || syntax.argument(named: "by") != nil || syntax.argument(named: "sensitivity") != nil || syntax.argument(named: "isContinuous") != nil || syntax.argument(named: "isHapticFeedbackEnabled") != nil || syntax.argument(named: "onChange") != nil || syntax.argument(named: "onIdle") != nil {
            let detent: SwiftUICore.Binding<V> = syntax.argument(named: "detent")?.expression.flatMap { SwiftUICore.Binding<V>(syntax: $0) }
            let from: V = syntax.argument(named: "from")?.expression.flatMap { V(syntax: $0) }
            let through: V = syntax.argument(named: "through")?.expression.flatMap { V(syntax: $0) }
            let by: V.Stride = syntax.argument(named: "by")?.expression.flatMap { V.Stride(syntax: $0) }
            let sensitivity: SwiftUI.DigitalCrownRotationalSensitivity = syntax.argument(named: "sensitivity")?.expression.flatMap { SwiftUI.DigitalCrownRotationalSensitivity(syntax: $0) } ?? .high
            let isContinuous: Swift.Bool = syntax.argument(named: "isContinuous")?.expression.flatMap { Swift.Bool(syntax: $0) } ?? false
            let isHapticFeedbackEnabled: Swift.Bool = syntax.argument(named: "isHapticFeedbackEnabled")?.expression.flatMap { Swift.Bool(syntax: $0) } ?? true
            let onChange: (SwiftUI.DigitalCrownEvent) -> Swift.Void = syntax.argument(named: "onChange")?.expression.flatMap { (SwiftUI.DigitalCrownEvent) -> Swift.Void(syntax: $0) } ?? { _ in }
            let onIdle: () -> Swift.Void = syntax.argument(named: "onIdle")?.expression.flatMap { () -> Swift.Void(syntax: $0) } ?? { }
            self = .digitalCrownRotationWithSwiftUICoreBindingVVVVStrideSwiftUIDigitalCrownRotationalSensitivitySwiftBoolSwiftBoolescapingSwiftUIDigitalCrownEventSwiftVoidescapingSwiftVoid(detent: detent, from: from, through: through, by: by, sensitivity: sensitivity, isContinuous: isContinuous, isHapticFeedbackEnabled: isHapticFeedbackEnabled, onChange: onChange, onIdle: onIdle)
            return
        }
        if syntax.argument(named: "detent") != nil || syntax.argument(named: "from") != nil || syntax.argument(named: "through") != nil || syntax.argument(named: "by") != nil || syntax.argument(named: "sensitivity") != nil || syntax.argument(named: "isContinuous") != nil || syntax.argument(named: "isHapticFeedbackEnabled") != nil || syntax.argument(named: "onChange") != nil || syntax.argument(named: "onIdle") != nil {
            let detent: SwiftUICore.Binding<V> = syntax.argument(named: "detent")?.expression.flatMap { SwiftUICore.Binding<V>(syntax: $0) }
            let from: V = syntax.argument(named: "from")?.expression.flatMap { V(syntax: $0) }
            let through: V = syntax.argument(named: "through")?.expression.flatMap { V(syntax: $0) }
            let by: V.Stride = syntax.argument(named: "by")?.expression.flatMap { V.Stride(syntax: $0) }
            let sensitivity: SwiftUI.DigitalCrownRotationalSensitivity = syntax.argument(named: "sensitivity")?.expression.flatMap { SwiftUI.DigitalCrownRotationalSensitivity(syntax: $0) } ?? .high
            let isContinuous: Swift.Bool = syntax.argument(named: "isContinuous")?.expression.flatMap { Swift.Bool(syntax: $0) } ?? false
            let isHapticFeedbackEnabled: Swift.Bool = syntax.argument(named: "isHapticFeedbackEnabled")?.expression.flatMap { Swift.Bool(syntax: $0) } ?? true
            let onChange: (SwiftUI.DigitalCrownEvent) -> Swift.Void = syntax.argument(named: "onChange")?.expression.flatMap { (SwiftUI.DigitalCrownEvent) -> Swift.Void(syntax: $0) } ?? { _ in }
            let onIdle: () -> Swift.Void = syntax.argument(named: "onIdle")?.expression.flatMap { () -> Swift.Void(syntax: $0) } ?? { }
            self = .digitalCrownRotationWithSwiftUICoreBindingVVVVStrideSwiftUIDigitalCrownRotationalSensitivitySwiftBoolSwiftBoolescapingSwiftUIDigitalCrownEventSwiftVoidescapingSwiftVoid1(detent: detent, from: from, through: through, by: by, sensitivity: sensitivity, isContinuous: isContinuous, isHapticFeedbackEnabled: isHapticFeedbackEnabled, onChange: onChange, onIdle: onIdle)
            return
        }
        if syntax.argument(named: "from") != nil || syntax.argument(named: "through") != nil || syntax.argument(named: "sensitivity") != nil || syntax.argument(named: "isContinuous") != nil || syntax.argument(named: "isHapticFeedbackEnabled") != nil || syntax.argument(named: "onChange") != nil || syntax.argument(named: "onIdle") != nil {
            let value0: SwiftUICore.Binding<V> = (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil).flatMap { SwiftUICore.Binding<V>(syntax: $0) }
            let from: V = syntax.argument(named: "from")?.expression.flatMap { V(syntax: $0) }
            let through: V = syntax.argument(named: "through")?.expression.flatMap { V(syntax: $0) }
            let sensitivity: SwiftUI.DigitalCrownRotationalSensitivity = syntax.argument(named: "sensitivity")?.expression.flatMap { SwiftUI.DigitalCrownRotationalSensitivity(syntax: $0) } ?? .high
            let isContinuous: Swift.Bool = syntax.argument(named: "isContinuous")?.expression.flatMap { Swift.Bool(syntax: $0) } ?? false
            let isHapticFeedbackEnabled: Swift.Bool = syntax.argument(named: "isHapticFeedbackEnabled")?.expression.flatMap { Swift.Bool(syntax: $0) } ?? true
            let onChange: (SwiftUI.DigitalCrownEvent) -> Swift.Void = syntax.argument(named: "onChange")?.expression.flatMap { (SwiftUI.DigitalCrownEvent) -> Swift.Void(syntax: $0) } ?? { _ in }
            let onIdle: () -> Swift.Void = syntax.argument(named: "onIdle")?.expression.flatMap { () -> Swift.Void(syntax: $0) } ?? { }
            self = .digitalCrownRotationWithSwiftUICoreBindingVVVSwiftUIDigitalCrownRotationalSensitivitySwiftBoolSwiftBoolescapingSwiftUIDigitalCrownEventSwiftVoidescapingSwiftVoid(value0, from: from, through: through, sensitivity: sensitivity, isContinuous: isContinuous, isHapticFeedbackEnabled: isHapticFeedbackEnabled, onChange: onChange, onIdle: onIdle)
            return
        }
        let value0: SwiftUICore.Binding<V> = (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil).flatMap { SwiftUICore.Binding<V>(syntax: $0) }
        let onChange: (SwiftUI.DigitalCrownEvent) -> Swift.Void = syntax.argument(named: "onChange")?.expression.flatMap { (SwiftUI.DigitalCrownEvent) -> Swift.Void(syntax: $0) } ?? { _ in }
        let onIdle: () -> Swift.Void = syntax.argument(named: "onIdle")?.expression.flatMap { () -> Swift.Void(syntax: $0) } ?? { }
        self = .digitalCrownRotationWithSwiftUICoreBindingVescapingSwiftUIDigitalCrownEventSwiftVoidescapingSwiftVoid(value0, onChange: onChange, onIdle: onIdle)
        return
        throw ModifierParseError.noMatchingVariant(modifier: "DigitalCrownRotationModifier", found: syntax.arguments.count)
    }
    public func body<Library: ElementLibrary>(content: Content, library: Library.Type) -> some View {
        switch self {
        case .digitalCrownRotationWithSwiftUICoreBindingVVVVStrideOptionalSwiftUIDigitalCrownRotationalSensitivitySwiftBoolSwiftBool(let value0, let from, let through, let by, let sensitivity, let isContinuous, let isHapticFeedbackEnabled):
            content.digitalCrownRotation(value0, from: from, through: through, by: by, sensitivity: sensitivity, isContinuous: isContinuous, isHapticFeedbackEnabled: isHapticFeedbackEnabled)
        case .digitalCrownRotationWithSwiftUICoreBindingV(let value0):
            content.digitalCrownRotation(value0)
        case .digitalCrownRotationWithSwiftUICoreBindingVVVVStrideSwiftUIDigitalCrownRotationalSensitivitySwiftBoolSwiftBoolescapingSwiftUIDigitalCrownEventSwiftVoidescapingSwiftVoid(let detent, let from, let through, let by, let sensitivity, let isContinuous, let isHapticFeedbackEnabled, let onChange, let onIdle):
            content.digitalCrownRotation(detent: detent, from: from, through: through, by: by, sensitivity: sensitivity, isContinuous: isContinuous, isHapticFeedbackEnabled: isHapticFeedbackEnabled, onChange: onChange, onIdle: onIdle)
        case .digitalCrownRotationWithSwiftUICoreBindingVVVVStrideSwiftUIDigitalCrownRotationalSensitivitySwiftBoolSwiftBoolescapingSwiftUIDigitalCrownEventSwiftVoidescapingSwiftVoid1(let detent, let from, let through, let by, let sensitivity, let isContinuous, let isHapticFeedbackEnabled, let onChange, let onIdle):
            content.digitalCrownRotation(detent: detent, from: from, through: through, by: by, sensitivity: sensitivity, isContinuous: isContinuous, isHapticFeedbackEnabled: isHapticFeedbackEnabled, onChange: onChange, onIdle: onIdle)
        case .digitalCrownRotationWithSwiftUICoreBindingVVVSwiftUIDigitalCrownRotationalSensitivitySwiftBoolSwiftBoolescapingSwiftUIDigitalCrownEventSwiftVoidescapingSwiftVoid(let value0, let from, let through, let sensitivity, let isContinuous, let isHapticFeedbackEnabled, let onChange, let onIdle):
            content.digitalCrownRotation(value0, from: from, through: through, sensitivity: sensitivity, isContinuous: isContinuous, isHapticFeedbackEnabled: isHapticFeedbackEnabled, onChange: onChange, onIdle: onIdle)
        case .digitalCrownRotationWithSwiftUICoreBindingVescapingSwiftUIDigitalCrownEventSwiftVoidescapingSwiftVoid(let value0, let onChange, let onIdle):
            content.digitalCrownRotation(value0, onChange: onChange, onIdle: onIdle)
        }
    }
}