import SwiftUI
import SwiftSyntax

/// Generated modifier enum for MatchedGeometryEffectModifier modifiers.
/// Generated by ModifierSwift.
public enum MatchedGeometryEffectModifier: Sendable {
    case matchedGeometryEffect(id: AnyHashable, in: SwiftUICore.Namespace.AnyHashable, properties: SwiftUICore.MatchedGeometryProperties, anchor: SwiftUICore.UnitPoint, isSource: Swift.Bool)
}

extension MatchedGeometryEffectModifier: RuntimeViewModifier {
    public static var baseName: String { "matchedGeometryEffect" }

    public init(syntax: FunctionCallExprSyntax) throws {
        let id: AnyHashable = syntax.argument(named: "id")?.expression.flatMap { AnyHashable(syntax: $0) }
        let in: SwiftUICore.Namespace.AnyHashable = syntax.argument(named: "in")?.expression.flatMap { SwiftUICore.Namespace.AnyHashable(syntax: $0) }
        let properties: SwiftUICore.MatchedGeometryProperties = syntax.argument(named: "properties")?.expression.flatMap { SwiftUICore.MatchedGeometryProperties(syntax: $0) } ?? .frame
        let anchor: SwiftUICore.UnitPoint = syntax.argument(named: "anchor")?.expression.flatMap { SwiftUICore.UnitPoint(syntax: $0) } ?? .center
        let isSource: Swift.Bool = syntax.argument(named: "isSource")?.expression.flatMap { Swift.Bool(syntax: $0) } ?? true
        self = .matchedGeometryEffect(id: id, in: in, properties: properties, anchor: anchor, isSource: isSource)
        return
        throw ModifierParseError.noMatchingVariant(modifier: "MatchedGeometryEffectModifier", found: syntax.arguments.count)
    }
    public func body<Library: ElementLibrary>(content: Content, library: Library.Type) -> some View {
        switch self {
        case .matchedGeometryEffect(let id, let in, let properties, let anchor, let isSource):
            content.matchedGeometryEffect(id: id, in: in, properties: properties, anchor: anchor, isSource: isSource)
        }
    }
}