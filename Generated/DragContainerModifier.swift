import SwiftUI
import SwiftSyntax

/// Generated modifier enum for DragContainerModifier modifiers.
/// Generated by ModifierSwift.
public enum DragContainerModifier: Sendable {
    case dragContainerWithItemTypeSwiftKeyPathItemItemIDSwiftUICoreNamespaceIDOptionalescapingdraggedItemIDItemIDData(for: Item.Type, itemID: Swift.KeyPath<Item, ItemID>, in: SwiftUICore.Namespace.ID?, (_ draggedItemID: ItemID) -> Data)
    case dragContainerWithItemTypeSwiftUICoreNamespaceIDOptionalescapingdraggedItemIDsSwiftArrayItemIDData(for: Item.Type, in: SwiftUICore.Namespace.ID?, (_ draggedItemIDs: Swift.Array<Item.ID>) -> Data)
    case dragContainerWithItemTypeSwiftUICoreNamespaceIDOptionalescapingdraggedItemIDItemIDData(for: Item.Type, in: SwiftUICore.Namespace.ID?, (_ draggedItemID: Item.ID) -> Data)
    case dragContainerWithItemTypeSwiftKeyPathItemItemIDSwiftUICoreNamespaceIDOptionalescapingdraggedItemIDsSwiftArrayItemIDData(for: Item.Type, itemID: Swift.KeyPath<Item, ItemID>, in: SwiftUICore.Namespace.ID?, (_ draggedItemIDs: Swift.Array<ItemID>) -> Data)
}

extension DragContainerModifier: RuntimeViewModifier {
    public static var baseName: String { "dragContainer" }

    public init(syntax: FunctionCallExprSyntax) throws {
        if syntax.argument(named: "for") != nil || syntax.argument(named: "itemID") != nil || syntax.argument(named: "in") != nil {
            let for: Item.Type = syntax.argument(named: "for")?.expression.flatMap { Item.Type(syntax: $0) } ?? Item.self
            let itemID: Swift.KeyPath<Item, ItemID> = syntax.argument(named: "itemID")?.expression.flatMap { Swift.KeyPath<Item, ItemID>(syntax: $0) }
            let in: SwiftUICore.Namespace.ID? = syntax.argument(named: "in")?.expression.flatMap { SwiftUICore.Namespace.ID(syntax: $0) } ?? nil
            let value3: (_ draggedItemID: ItemID) -> Data = (syntax.arguments.count > 3 ? syntax.arguments[3].expression : nil).flatMap { (_ draggedItemID: ItemID) -> Data(syntax: $0) }
            self = .dragContainerWithItemTypeSwiftKeyPathItemItemIDSwiftUICoreNamespaceIDOptionalescapingdraggedItemIDItemIDData(for: for, itemID: itemID, in: in, value3)
            return
        }
        if syntax.argument(named: "for") != nil || syntax.argument(named: "in") != nil {
            let for: Item.Type = syntax.argument(named: "for")?.expression.flatMap { Item.Type(syntax: $0) } ?? Item.self
            let in: SwiftUICore.Namespace.ID? = syntax.argument(named: "in")?.expression.flatMap { SwiftUICore.Namespace.ID(syntax: $0) } ?? nil
            let value2: (_ draggedItemIDs: Swift.Array<Item.ID>) -> Data = (syntax.arguments.count > 2 ? syntax.arguments[2].expression : nil).flatMap { (_ draggedItemIDs: Swift.Array<Item.ID>) -> Data(syntax: $0) }
            self = .dragContainerWithItemTypeSwiftUICoreNamespaceIDOptionalescapingdraggedItemIDsSwiftArrayItemIDData(for: for, in: in, value2)
            return
        }
        if syntax.argument(named: "for") != nil || syntax.argument(named: "in") != nil {
            let for: Item.Type = syntax.argument(named: "for")?.expression.flatMap { Item.Type(syntax: $0) } ?? Item.self
            let in: SwiftUICore.Namespace.ID? = syntax.argument(named: "in")?.expression.flatMap { SwiftUICore.Namespace.ID(syntax: $0) } ?? nil
            let value2: (_ draggedItemID: Item.ID) -> Data = (syntax.arguments.count > 2 ? syntax.arguments[2].expression : nil).flatMap { (_ draggedItemID: Item.ID) -> Data(syntax: $0) }
            self = .dragContainerWithItemTypeSwiftUICoreNamespaceIDOptionalescapingdraggedItemIDItemIDData(for: for, in: in, value2)
            return
        }
        let for: Item.Type = syntax.argument(named: "for")?.expression.flatMap { Item.Type(syntax: $0) } ?? Item.self
        let itemID: Swift.KeyPath<Item, ItemID> = syntax.argument(named: "itemID")?.expression.flatMap { Swift.KeyPath<Item, ItemID>(syntax: $0) }
        let in: SwiftUICore.Namespace.ID? = syntax.argument(named: "in")?.expression.flatMap { SwiftUICore.Namespace.ID(syntax: $0) } ?? nil
        let value3: (_ draggedItemIDs: Swift.Array<ItemID>) -> Data = (syntax.arguments.count > 3 ? syntax.arguments[3].expression : nil).flatMap { (_ draggedItemIDs: Swift.Array<ItemID>) -> Data(syntax: $0) }
        self = .dragContainerWithItemTypeSwiftKeyPathItemItemIDSwiftUICoreNamespaceIDOptionalescapingdraggedItemIDsSwiftArrayItemIDData(for: for, itemID: itemID, in: in, value3)
        return
        throw ModifierParseError.noMatchingVariant(modifier: "DragContainerModifier", found: syntax.arguments.count)
    }
    public func body<Library: ElementLibrary>(content: Content, library: Library.Type) -> some View {
        switch self {
        case .dragContainerWithItemTypeSwiftKeyPathItemItemIDSwiftUICoreNamespaceIDOptionalescapingdraggedItemIDItemIDData(let for, let itemID, let in, let value3):
            content.dragContainer(for: for, itemID: itemID, in: in, value3)
        case .dragContainerWithItemTypeSwiftUICoreNamespaceIDOptionalescapingdraggedItemIDsSwiftArrayItemIDData(let for, let in, let value2):
            content.dragContainer(for: for, in: in, value2)
        case .dragContainerWithItemTypeSwiftUICoreNamespaceIDOptionalescapingdraggedItemIDItemIDData(let for, let in, let value2):
            content.dragContainer(for: for, in: in, value2)
        case .dragContainerWithItemTypeSwiftKeyPathItemItemIDSwiftUICoreNamespaceIDOptionalescapingdraggedItemIDsSwiftArrayItemIDData(let for, let itemID, let in, let value3):
            content.dragContainer(for: for, itemID: itemID, in: in, value3)
        }
    }
}