import SwiftUI
import SwiftSyntax

/// Generated modifier enum for DragContainerModifier modifiers.
///
/// This enum provides type-safe access to SwiftUI view modifiers.
/// Generated by ModifierSwift.
public enum DragContainerModifier: Sendable {
    case dragContainerWithTypeKeyPathItemItemIDIDOptionalClosureData(for: Item.Type, itemID: Swift.KeyPath<Item, ItemID>, in: SwiftUICore.Namespace.ID?)
    case dragContainerWithTypeIDOptionalClosureData(for: Item.Type, in: SwiftUICore.Namespace.ID?)
    case dragContainerWithTypeIDOptionalClosureData1(for: Item.Type, in: SwiftUICore.Namespace.ID?)
    case dragContainerWithTypeKeyPathItemItemIDIDOptionalClosureData1(for: Item.Type, itemID: Swift.KeyPath<Item, ItemID>, in: SwiftUICore.Namespace.ID?)
}

extension DragContainerModifier: RuntimeViewModifier {
    public static var baseName: String { "dragContainer" }

    public init(syntax: FunctionCallExprSyntax) throws {
        if syntax.argument(named: "for") != nil || syntax.argument(named: "itemID") != nil || syntax.argument(named: "in") != nil {
            let for: Item.Type = syntax.argument(named: "for")?.expression.flatMap { Item.Type(syntax: $0) } ?? Item.self
            let itemID: Swift.KeyPath<Item, ItemID> = syntax.argument(named: "itemID")?.expression.flatMap { Swift.KeyPath<Item, ItemID>(syntax: $0) }
            let in: SwiftUICore.Namespace.ID? = syntax.argument(named: "in")?.expression.flatMap { SwiftUICore.Namespace.ID(syntax: $0) } ?? nil
            self = .dragContainerWithTypeKeyPathItemItemIDIDOptionalClosureData(for: for, itemID: itemID, in: in)
            return
        }
        if syntax.argument(named: "for") != nil || syntax.argument(named: "in") != nil {
            let for: Item.Type = syntax.argument(named: "for")?.expression.flatMap { Item.Type(syntax: $0) } ?? Item.self
            let in: SwiftUICore.Namespace.ID? = syntax.argument(named: "in")?.expression.flatMap { SwiftUICore.Namespace.ID(syntax: $0) } ?? nil
            self = .dragContainerWithTypeIDOptionalClosureData(for: for, in: in)
            return
        }
        if syntax.argument(named: "for") != nil || syntax.argument(named: "in") != nil {
            let for: Item.Type = syntax.argument(named: "for")?.expression.flatMap { Item.Type(syntax: $0) } ?? Item.self
            let in: SwiftUICore.Namespace.ID? = syntax.argument(named: "in")?.expression.flatMap { SwiftUICore.Namespace.ID(syntax: $0) } ?? nil
            self = .dragContainerWithTypeIDOptionalClosureData1(for: for, in: in)
            return
        }
        let for: Item.Type = syntax.argument(named: "for")?.expression.flatMap { Item.Type(syntax: $0) } ?? Item.self
        let itemID: Swift.KeyPath<Item, ItemID> = syntax.argument(named: "itemID")?.expression.flatMap { Swift.KeyPath<Item, ItemID>(syntax: $0) }
        let in: SwiftUICore.Namespace.ID? = syntax.argument(named: "in")?.expression.flatMap { SwiftUICore.Namespace.ID(syntax: $0) } ?? nil
        self = .dragContainerWithTypeKeyPathItemItemIDIDOptionalClosureData1(for: for, itemID: itemID, in: in)
        return
    }
    public func body(content: Content) -> some View {
        switch self {
        case .dragContainerWithTypeKeyPathItemItemIDIDOptionalClosureData(let for, let itemID, let in):
            content.dragContainer(for: for, itemID: itemID, in: in)
        case .dragContainerWithTypeIDOptionalClosureData(let for, let in):
            content.dragContainer(for: for, in: in)
        case .dragContainerWithTypeIDOptionalClosureData1(let for, let in):
            content.dragContainer(for: for, in: in)
        case .dragContainerWithTypeKeyPathItemItemIDIDOptionalClosureData1(let for, let itemID, let in):
            content.dragContainer(for: for, itemID: itemID, in: in)
        }
    }
}