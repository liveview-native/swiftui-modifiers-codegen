import SwiftUI
import SwiftSyntax

/// Generated modifier enum for DragContainerModifier modifiers.
///
/// This enum provides type-safe access to SwiftUI view modifiers.
/// Generated by ModifierSwift.
public enum DragContainerModifier: Sendable {
    case dragContainerWithTypeKeyPathItemItemIDIDOptionalClosureData(for: Item.Type, itemID: Swift.KeyPath<Item, ItemID>, in: SwiftUICore.Namespace.ID?)
    case dragContainerWithTypeIDOptionalClosureData(for: Item.Type, in: SwiftUICore.Namespace.ID?)
    case dragContainerWithTypeIDOptionalClosureData1(for: Item.Type, in: SwiftUICore.Namespace.ID?)
    case dragContainerWithTypeKeyPathItemItemIDIDOptionalClosureData1(for: Item.Type, itemID: Swift.KeyPath<Item, ItemID>, in: SwiftUICore.Namespace.ID?)
}

extension DragContainerModifier: RuntimeViewModifier {
    public static var baseName: String { "dragContainer" }

    public init(syntax: FunctionCallExprSyntax) throws {
        switch syntax.arguments.count {
        case 2:
            let for = if let expr = syntax.argument(named: "for")?.expression { Item.Type(syntax: expr) } else { nil }
            let in = if let expr = syntax.argument(named: "in")?.expression { SwiftUICore.Namespace.ID(syntax: expr) } else { nil }
            self = .dragContainerWithTypeIDOptionalClosureData(for: for, in: in)
        case 3:
            if let expr_itemID = syntax.argument(named: "itemID")?.expression, let itemID = Swift.KeyPath<Item, ItemID>(syntax: expr_itemID) {
                let for = { if let expr = syntax.argument(named: "for")?.expression, let parsed = Item.Type(syntax: expr) { return parsed } else { return Item.self } }()
                let in = { if let expr = syntax.argument(named: "in")?.expression, let parsed = SwiftUICore.Namespace.ID(syntax: expr) { return parsed } else { return nil } }()
                self = .dragContainerWithTypeKeyPathItemItemIDIDOptionalClosureData(for: for, itemID: itemID, in: in)
            } else if let expr_itemID = syntax.argument(named: "itemID")?.expression, let itemID = Swift.KeyPath<Item, ItemID>(syntax: expr_itemID) {
                let for = { if let expr = syntax.argument(named: "for")?.expression, let parsed = Item.Type(syntax: expr) { return parsed } else { return Item.self } }()
                let in = { if let expr = syntax.argument(named: "in")?.expression, let parsed = SwiftUICore.Namespace.ID(syntax: expr) { return parsed } else { return nil } }()
                self = .dragContainerWithTypeKeyPathItemItemIDIDOptionalClosureData1(for: for, itemID: itemID, in: in)
            } else {
                throw ModifierParseError.invalidArguments(modifier: "DragContainerModifier", variant: "multiple variants", expectedTypes: "Item.Type, Swift.KeyPath<Item, ItemID>, SwiftUICore.Namespace.ID? or Item.Type, Swift.KeyPath<Item, ItemID>, SwiftUICore.Namespace.ID?")
            }
        default:
            throw ModifierParseError.unexpectedArgumentCount(modifier: "DragContainerModifier", expected: [2, 3], found: syntax.arguments.count)
        }
    }

    public func body(content: Content) -> some View {
        switch self {
        case .dragContainerWithTypeKeyPathItemItemIDIDOptionalClosureData(let for, let itemID, let in):
            content.dragContainer(for: for, itemID: itemID, in: in)
        case .dragContainerWithTypeIDOptionalClosureData(let for, let in):
            content.dragContainer(for: for, in: in)
        case .dragContainerWithTypeIDOptionalClosureData1(let for, let in):
            content.dragContainer(for: for, in: in)
        case .dragContainerWithTypeKeyPathItemItemIDIDOptionalClosureData1(let for, let itemID, let in):
            content.dragContainer(for: for, itemID: itemID, in: in)
        }
    }
}