import SwiftUI
import SwiftSyntax

/// Generated modifier enum for FileExporterModifier modifiers.
/// Generated by ModifierSwift.
public enum FileExporterModifier: Sendable {
    case fileExporterWithSwiftUICoreBindingSwiftBoolDOptionalUniformTypeIdentifiersUTTypeSwiftStringOptionalescapingresultSwiftResultFoundationURLanySwiftErrorSwiftVoid(isPresented: SwiftUICore.Binding<Swift.Bool>, document: D?, contentType: UniformTypeIdentifiers.UTType, defaultFilename: Swift.String?, onCompletion: (_ result: Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void)
    case fileExporterWithSwiftUICoreBindingSwiftBoolCUniformTypeIdentifiersUTTypeescapingresultSwiftResultArrayFoundationURLanySwiftErrorSwiftVoid(isPresented: SwiftUICore.Binding<Swift.Bool>, documents: C, contentType: UniformTypeIdentifiers.UTType, onCompletion: (_ result: Swift.Result<[Foundation.URL], any Swift.Error>) -> Swift.Void)
    case fileExporterWithSwiftUICoreBindingSwiftBoolDOptionalUniformTypeIdentifiersUTTypeSwiftStringOptionalescapingresultSwiftResultFoundationURLanySwiftErrorSwiftVoid1(isPresented: SwiftUICore.Binding<Swift.Bool>, document: D?, contentType: UniformTypeIdentifiers.UTType, defaultFilename: Swift.String?, onCompletion: (_ result: Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void)
    case fileExporterWithSwiftUICoreBindingSwiftBoolCUniformTypeIdentifiersUTTypeescapingresultSwiftResultArrayFoundationURLanySwiftErrorSwiftVoid1(isPresented: SwiftUICore.Binding<Swift.Bool>, documents: C, contentType: UniformTypeIdentifiers.UTType, onCompletion: (_ result: Swift.Result<[Foundation.URL], any Swift.Error>) -> Swift.Void)
    case fileExporterWithSwiftUICoreBindingSwiftBoolTOptionalArrayUniformTypeIdentifiersUTTypeSwiftStringOptionalescapingSwiftResultFoundationURLanySwiftErrorSwiftVoidescapingSwiftVoid(isPresented: SwiftUICore.Binding<Swift.Bool>, item: T?, contentTypes: [UniformTypeIdentifiers.UTType], defaultFilename: Swift.String?, onCompletion: (Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void, onCancellation: () -> Swift.Void)
    case fileExporterWithSwiftUICoreBindingSwiftBoolCArrayUniformTypeIdentifiersUTTypeescapingSwiftResultArrayFoundationURLanySwiftErrorSwiftVoidescapingSwiftVoid(isPresented: SwiftUICore.Binding<Swift.Bool>, items: C, contentTypes: [UniformTypeIdentifiers.UTType], onCompletion: (Swift.Result<[Foundation.URL], any Swift.Error>) -> Swift.Void, onCancellation: () -> Swift.Void)
    case fileExporterWithSwiftUICoreBindingSwiftBoolDOptionalArrayUniformTypeIdentifiersUTTypeSwiftStringOptionalescapingSwiftResultFoundationURLanySwiftErrorSwiftVoidescapingSwiftVoid(isPresented: SwiftUICore.Binding<Swift.Bool>, document: D?, contentTypes: [UniformTypeIdentifiers.UTType], defaultFilename: Swift.String?, onCompletion: (Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void, onCancellation: () -> Swift.Void)
    case fileExporterWithSwiftUICoreBindingSwiftBoolDOptionalArrayUniformTypeIdentifiersUTTypeSwiftStringOptionalescapingSwiftResultFoundationURLanySwiftErrorSwiftVoidescapingSwiftVoid1(isPresented: SwiftUICore.Binding<Swift.Bool>, document: D?, contentTypes: [UniformTypeIdentifiers.UTType], defaultFilename: Swift.String?, onCompletion: (Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void, onCancellation: () -> Swift.Void)
    case fileExporterWithSwiftUICoreBindingSwiftBoolCArrayUniformTypeIdentifiersUTTypeescapingSwiftResultArrayFoundationURLanySwiftErrorSwiftVoidescapingSwiftVoid1(isPresented: SwiftUICore.Binding<Swift.Bool>, documents: C, contentTypes: [UniformTypeIdentifiers.UTType], onCompletion: (Swift.Result<[Foundation.URL], any Swift.Error>) -> Swift.Void, onCancellation: () -> Swift.Void)
    case fileExporterWithSwiftUICoreBindingSwiftBoolCArrayUniformTypeIdentifiersUTTypeescapingSwiftResultArrayFoundationURLanySwiftErrorSwiftVoidescapingSwiftVoid2(isPresented: SwiftUICore.Binding<Swift.Bool>, documents: C, contentTypes: [UniformTypeIdentifiers.UTType], onCompletion: (Swift.Result<[Foundation.URL], any Swift.Error>) -> Swift.Void, onCancellation: () -> Swift.Void)
}

extension FileExporterModifier: RuntimeViewModifier {
    public static var baseName: String { "fileExporter" }

    public init(syntax: FunctionCallExprSyntax) throws {
        if syntax.arguments.count == 4 {
            if let isPresented = SwiftUICore.Binding<Swift.Bool>(syntax: syntax.argument(named: "isPresented")?.expression!), let documents = C(syntax: syntax.argument(named: "documents")?.expression!), let contentType = UniformTypeIdentifiers.UTType(syntax: syntax.argument(named: "contentType")?.expression!), let onCompletion = (_ result: Swift.Result<[Foundation.URL], any Swift.Error>) -> Swift.Void(syntax: syntax.argument(named: "onCompletion")?.expression!) {
                self = .fileExporterWithSwiftUICoreBindingSwiftBoolCUniformTypeIdentifiersUTTypeescapingresultSwiftResultArrayFoundationURLanySwiftErrorSwiftVoid(isPresented: isPresented, documents: documents, contentType: contentType, onCompletion: onCompletion)
                return
            }
            if let isPresented = SwiftUICore.Binding<Swift.Bool>(syntax: syntax.argument(named: "isPresented")?.expression!), let documents = C(syntax: syntax.argument(named: "documents")?.expression!), let contentType = UniformTypeIdentifiers.UTType(syntax: syntax.argument(named: "contentType")?.expression!), let onCompletion = (_ result: Swift.Result<[Foundation.URL], any Swift.Error>) -> Swift.Void(syntax: syntax.argument(named: "onCompletion")?.expression!) {
                self = .fileExporterWithSwiftUICoreBindingSwiftBoolCUniformTypeIdentifiersUTTypeescapingresultSwiftResultArrayFoundationURLanySwiftErrorSwiftVoid1(isPresented: isPresented, documents: documents, contentType: contentType, onCompletion: onCompletion)
                return
            }
        }
        if syntax.argument(named: "isPresented") != nil || syntax.argument(named: "document") != nil || syntax.argument(named: "contentType") != nil || syntax.argument(named: "defaultFilename") != nil || syntax.argument(named: "onCompletion") != nil {
            let isPresented: SwiftUICore.Binding<Swift.Bool> = syntax.argument(named: "isPresented")?.expression.flatMap { SwiftUICore.Binding<Swift.Bool>(syntax: $0) }
            let document: D? = syntax.argument(named: "document")?.expression.flatMap { D(syntax: $0) } ?? nil
            let contentType: UniformTypeIdentifiers.UTType = syntax.argument(named: "contentType")?.expression.flatMap { UniformTypeIdentifiers.UTType(syntax: $0) }
            let defaultFilename: Swift.String? = syntax.argument(named: "defaultFilename")?.expression.flatMap { Swift.String(syntax: $0) } ?? nil
            let onCompletion: (_ result: Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void = syntax.argument(named: "onCompletion")?.expression.flatMap { (_ result: Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void(syntax: $0) }
            self = .fileExporterWithSwiftUICoreBindingSwiftBoolDOptionalUniformTypeIdentifiersUTTypeSwiftStringOptionalescapingresultSwiftResultFoundationURLanySwiftErrorSwiftVoid(isPresented: isPresented, document: document, contentType: contentType, defaultFilename: defaultFilename, onCompletion: onCompletion)
            return
        }
        if syntax.argument(named: "isPresented") != nil || syntax.argument(named: "document") != nil || syntax.argument(named: "contentType") != nil || syntax.argument(named: "defaultFilename") != nil || syntax.argument(named: "onCompletion") != nil {
            let isPresented: SwiftUICore.Binding<Swift.Bool> = syntax.argument(named: "isPresented")?.expression.flatMap { SwiftUICore.Binding<Swift.Bool>(syntax: $0) }
            let document: D? = syntax.argument(named: "document")?.expression.flatMap { D(syntax: $0) } ?? nil
            let contentType: UniformTypeIdentifiers.UTType = syntax.argument(named: "contentType")?.expression.flatMap { UniformTypeIdentifiers.UTType(syntax: $0) }
            let defaultFilename: Swift.String? = syntax.argument(named: "defaultFilename")?.expression.flatMap { Swift.String(syntax: $0) } ?? nil
            let onCompletion: (_ result: Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void = syntax.argument(named: "onCompletion")?.expression.flatMap { (_ result: Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void(syntax: $0) }
            self = .fileExporterWithSwiftUICoreBindingSwiftBoolDOptionalUniformTypeIdentifiersUTTypeSwiftStringOptionalescapingresultSwiftResultFoundationURLanySwiftErrorSwiftVoid1(isPresented: isPresented, document: document, contentType: contentType, defaultFilename: defaultFilename, onCompletion: onCompletion)
            return
        }
        if syntax.argument(named: "isPresented") != nil || syntax.argument(named: "item") != nil || syntax.argument(named: "contentTypes") != nil || syntax.argument(named: "defaultFilename") != nil || syntax.argument(named: "onCompletion") != nil || syntax.argument(named: "onCancellation") != nil {
            let isPresented: SwiftUICore.Binding<Swift.Bool> = syntax.argument(named: "isPresented")?.expression.flatMap { SwiftUICore.Binding<Swift.Bool>(syntax: $0) }
            let item: T? = syntax.argument(named: "item")?.expression.flatMap { T(syntax: $0) } ?? nil
            let contentTypes: [UniformTypeIdentifiers.UTType] = syntax.argument(named: "contentTypes")?.expression.flatMap { [UniformTypeIdentifiers.UTType](syntax: $0) } ?? []
            let defaultFilename: Swift.String? = syntax.argument(named: "defaultFilename")?.expression.flatMap { Swift.String(syntax: $0) } ?? nil
            let onCompletion: (Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void = syntax.argument(named: "onCompletion")?.expression.flatMap { (Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void(syntax: $0) }
            let onCancellation: () -> Swift.Void = syntax.argument(named: "onCancellation")?.expression.flatMap { () -> Swift.Void(syntax: $0) } ?? { }
            self = .fileExporterWithSwiftUICoreBindingSwiftBoolTOptionalArrayUniformTypeIdentifiersUTTypeSwiftStringOptionalescapingSwiftResultFoundationURLanySwiftErrorSwiftVoidescapingSwiftVoid(isPresented: isPresented, item: item, contentTypes: contentTypes, defaultFilename: defaultFilename, onCompletion: onCompletion, onCancellation: onCancellation)
            return
        }
        if syntax.argument(named: "isPresented") != nil || syntax.argument(named: "items") != nil || syntax.argument(named: "contentTypes") != nil || syntax.argument(named: "onCompletion") != nil || syntax.argument(named: "onCancellation") != nil {
            let isPresented: SwiftUICore.Binding<Swift.Bool> = syntax.argument(named: "isPresented")?.expression.flatMap { SwiftUICore.Binding<Swift.Bool>(syntax: $0) }
            let items: C = syntax.argument(named: "items")?.expression.flatMap { C(syntax: $0) }
            let contentTypes: [UniformTypeIdentifiers.UTType] = syntax.argument(named: "contentTypes")?.expression.flatMap { [UniformTypeIdentifiers.UTType](syntax: $0) } ?? []
            let onCompletion: (Swift.Result<[Foundation.URL], any Swift.Error>) -> Swift.Void = syntax.argument(named: "onCompletion")?.expression.flatMap { (Swift.Result<[Foundation.URL], any Swift.Error>) -> Swift.Void(syntax: $0) }
            let onCancellation: () -> Swift.Void = syntax.argument(named: "onCancellation")?.expression.flatMap { () -> Swift.Void(syntax: $0) } ?? { }
            self = .fileExporterWithSwiftUICoreBindingSwiftBoolCArrayUniformTypeIdentifiersUTTypeescapingSwiftResultArrayFoundationURLanySwiftErrorSwiftVoidescapingSwiftVoid(isPresented: isPresented, items: items, contentTypes: contentTypes, onCompletion: onCompletion, onCancellation: onCancellation)
            return
        }
        if syntax.argument(named: "isPresented") != nil || syntax.argument(named: "document") != nil || syntax.argument(named: "contentTypes") != nil || syntax.argument(named: "defaultFilename") != nil || syntax.argument(named: "onCompletion") != nil || syntax.argument(named: "onCancellation") != nil {
            let isPresented: SwiftUICore.Binding<Swift.Bool> = syntax.argument(named: "isPresented")?.expression.flatMap { SwiftUICore.Binding<Swift.Bool>(syntax: $0) }
            let document: D? = syntax.argument(named: "document")?.expression.flatMap { D(syntax: $0) } ?? nil
            let contentTypes: [UniformTypeIdentifiers.UTType] = syntax.argument(named: "contentTypes")?.expression.flatMap { [UniformTypeIdentifiers.UTType](syntax: $0) } ?? []
            let defaultFilename: Swift.String? = syntax.argument(named: "defaultFilename")?.expression.flatMap { Swift.String(syntax: $0) } ?? nil
            let onCompletion: (Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void = syntax.argument(named: "onCompletion")?.expression.flatMap { (Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void(syntax: $0) }
            let onCancellation: () -> Swift.Void = syntax.argument(named: "onCancellation")?.expression.flatMap { () -> Swift.Void(syntax: $0) } ?? {}
            self = .fileExporterWithSwiftUICoreBindingSwiftBoolDOptionalArrayUniformTypeIdentifiersUTTypeSwiftStringOptionalescapingSwiftResultFoundationURLanySwiftErrorSwiftVoidescapingSwiftVoid(isPresented: isPresented, document: document, contentTypes: contentTypes, defaultFilename: defaultFilename, onCompletion: onCompletion, onCancellation: onCancellation)
            return
        }
        if syntax.argument(named: "isPresented") != nil || syntax.argument(named: "document") != nil || syntax.argument(named: "contentTypes") != nil || syntax.argument(named: "defaultFilename") != nil || syntax.argument(named: "onCompletion") != nil || syntax.argument(named: "onCancellation") != nil {
            let isPresented: SwiftUICore.Binding<Swift.Bool> = syntax.argument(named: "isPresented")?.expression.flatMap { SwiftUICore.Binding<Swift.Bool>(syntax: $0) }
            let document: D? = syntax.argument(named: "document")?.expression.flatMap { D(syntax: $0) } ?? nil
            let contentTypes: [UniformTypeIdentifiers.UTType] = syntax.argument(named: "contentTypes")?.expression.flatMap { [UniformTypeIdentifiers.UTType](syntax: $0) } ?? []
            let defaultFilename: Swift.String? = syntax.argument(named: "defaultFilename")?.expression.flatMap { Swift.String(syntax: $0) } ?? nil
            let onCompletion: (Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void = syntax.argument(named: "onCompletion")?.expression.flatMap { (Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void(syntax: $0) }
            let onCancellation: () -> Swift.Void = syntax.argument(named: "onCancellation")?.expression.flatMap { () -> Swift.Void(syntax: $0) } ?? {}
            self = .fileExporterWithSwiftUICoreBindingSwiftBoolDOptionalArrayUniformTypeIdentifiersUTTypeSwiftStringOptionalescapingSwiftResultFoundationURLanySwiftErrorSwiftVoidescapingSwiftVoid1(isPresented: isPresented, document: document, contentTypes: contentTypes, defaultFilename: defaultFilename, onCompletion: onCompletion, onCancellation: onCancellation)
            return
        }
        if syntax.argument(named: "isPresented") != nil || syntax.argument(named: "documents") != nil || syntax.argument(named: "contentTypes") != nil || syntax.argument(named: "onCompletion") != nil || syntax.argument(named: "onCancellation") != nil {
            let isPresented: SwiftUICore.Binding<Swift.Bool> = syntax.argument(named: "isPresented")?.expression.flatMap { SwiftUICore.Binding<Swift.Bool>(syntax: $0) }
            let documents: C = syntax.argument(named: "documents")?.expression.flatMap { C(syntax: $0) }
            let contentTypes: [UniformTypeIdentifiers.UTType] = syntax.argument(named: "contentTypes")?.expression.flatMap { [UniformTypeIdentifiers.UTType](syntax: $0) } ?? []
            let onCompletion: (Swift.Result<[Foundation.URL], any Swift.Error>) -> Swift.Void = syntax.argument(named: "onCompletion")?.expression.flatMap { (Swift.Result<[Foundation.URL], any Swift.Error>) -> Swift.Void(syntax: $0) }
            let onCancellation: () -> Swift.Void = syntax.argument(named: "onCancellation")?.expression.flatMap { () -> Swift.Void(syntax: $0) } ?? {}
            self = .fileExporterWithSwiftUICoreBindingSwiftBoolCArrayUniformTypeIdentifiersUTTypeescapingSwiftResultArrayFoundationURLanySwiftErrorSwiftVoidescapingSwiftVoid1(isPresented: isPresented, documents: documents, contentTypes: contentTypes, onCompletion: onCompletion, onCancellation: onCancellation)
            return
        }
        let isPresented: SwiftUICore.Binding<Swift.Bool> = syntax.argument(named: "isPresented")?.expression.flatMap { SwiftUICore.Binding<Swift.Bool>(syntax: $0) }
        let documents: C = syntax.argument(named: "documents")?.expression.flatMap { C(syntax: $0) }
        let contentTypes: [UniformTypeIdentifiers.UTType] = syntax.argument(named: "contentTypes")?.expression.flatMap { [UniformTypeIdentifiers.UTType](syntax: $0) } ?? []
        let onCompletion: (Swift.Result<[Foundation.URL], any Swift.Error>) -> Swift.Void = syntax.argument(named: "onCompletion")?.expression.flatMap { (Swift.Result<[Foundation.URL], any Swift.Error>) -> Swift.Void(syntax: $0) }
        let onCancellation: () -> Swift.Void = syntax.argument(named: "onCancellation")?.expression.flatMap { () -> Swift.Void(syntax: $0) } ?? {}
        self = .fileExporterWithSwiftUICoreBindingSwiftBoolCArrayUniformTypeIdentifiersUTTypeescapingSwiftResultArrayFoundationURLanySwiftErrorSwiftVoidescapingSwiftVoid2(isPresented: isPresented, documents: documents, contentTypes: contentTypes, onCompletion: onCompletion, onCancellation: onCancellation)
        return
        throw ModifierParseError.noMatchingVariant(modifier: "FileExporterModifier", found: syntax.arguments.count)
    }
    public func body<Library: ElementLibrary>(content: Content, library: Library.Type) -> some View {
        switch self {
        case .fileExporterWithSwiftUICoreBindingSwiftBoolDOptionalUniformTypeIdentifiersUTTypeSwiftStringOptionalescapingresultSwiftResultFoundationURLanySwiftErrorSwiftVoid(let isPresented, let document, let contentType, let defaultFilename, let onCompletion):
            content.fileExporter(isPresented: isPresented, document: document, contentType: contentType, defaultFilename: defaultFilename, onCompletion: onCompletion)
        case .fileExporterWithSwiftUICoreBindingSwiftBoolCUniformTypeIdentifiersUTTypeescapingresultSwiftResultArrayFoundationURLanySwiftErrorSwiftVoid(let isPresented, let documents, let contentType, let onCompletion):
            content.fileExporter(isPresented: isPresented, documents: documents, contentType: contentType, onCompletion: onCompletion)
        case .fileExporterWithSwiftUICoreBindingSwiftBoolDOptionalUniformTypeIdentifiersUTTypeSwiftStringOptionalescapingresultSwiftResultFoundationURLanySwiftErrorSwiftVoid1(let isPresented, let document, let contentType, let defaultFilename, let onCompletion):
            content.fileExporter(isPresented: isPresented, document: document, contentType: contentType, defaultFilename: defaultFilename, onCompletion: onCompletion)
        case .fileExporterWithSwiftUICoreBindingSwiftBoolCUniformTypeIdentifiersUTTypeescapingresultSwiftResultArrayFoundationURLanySwiftErrorSwiftVoid1(let isPresented, let documents, let contentType, let onCompletion):
            content.fileExporter(isPresented: isPresented, documents: documents, contentType: contentType, onCompletion: onCompletion)
        case .fileExporterWithSwiftUICoreBindingSwiftBoolTOptionalArrayUniformTypeIdentifiersUTTypeSwiftStringOptionalescapingSwiftResultFoundationURLanySwiftErrorSwiftVoidescapingSwiftVoid(let isPresented, let item, let contentTypes, let defaultFilename, let onCompletion, let onCancellation):
            content.fileExporter(isPresented: isPresented, item: item, contentTypes: contentTypes, defaultFilename: defaultFilename, onCompletion: onCompletion, onCancellation: onCancellation)
        case .fileExporterWithSwiftUICoreBindingSwiftBoolCArrayUniformTypeIdentifiersUTTypeescapingSwiftResultArrayFoundationURLanySwiftErrorSwiftVoidescapingSwiftVoid(let isPresented, let items, let contentTypes, let onCompletion, let onCancellation):
            content.fileExporter(isPresented: isPresented, items: items, contentTypes: contentTypes, onCompletion: onCompletion, onCancellation: onCancellation)
        case .fileExporterWithSwiftUICoreBindingSwiftBoolDOptionalArrayUniformTypeIdentifiersUTTypeSwiftStringOptionalescapingSwiftResultFoundationURLanySwiftErrorSwiftVoidescapingSwiftVoid(let isPresented, let document, let contentTypes, let defaultFilename, let onCompletion, let onCancellation):
            content.fileExporter(isPresented: isPresented, document: document, contentTypes: contentTypes, defaultFilename: defaultFilename, onCompletion: onCompletion, onCancellation: onCancellation)
        case .fileExporterWithSwiftUICoreBindingSwiftBoolDOptionalArrayUniformTypeIdentifiersUTTypeSwiftStringOptionalescapingSwiftResultFoundationURLanySwiftErrorSwiftVoidescapingSwiftVoid1(let isPresented, let document, let contentTypes, let defaultFilename, let onCompletion, let onCancellation):
            content.fileExporter(isPresented: isPresented, document: document, contentTypes: contentTypes, defaultFilename: defaultFilename, onCompletion: onCompletion, onCancellation: onCancellation)
        case .fileExporterWithSwiftUICoreBindingSwiftBoolCArrayUniformTypeIdentifiersUTTypeescapingSwiftResultArrayFoundationURLanySwiftErrorSwiftVoidescapingSwiftVoid1(let isPresented, let documents, let contentTypes, let onCompletion, let onCancellation):
            content.fileExporter(isPresented: isPresented, documents: documents, contentTypes: contentTypes, onCompletion: onCompletion, onCancellation: onCancellation)
        case .fileExporterWithSwiftUICoreBindingSwiftBoolCArrayUniformTypeIdentifiersUTTypeescapingSwiftResultArrayFoundationURLanySwiftErrorSwiftVoidescapingSwiftVoid2(let isPresented, let documents, let contentTypes, let onCompletion, let onCancellation):
            content.fileExporter(isPresented: isPresented, documents: documents, contentTypes: contentTypes, onCompletion: onCompletion, onCancellation: onCancellation)
        }
    }
}