import SwiftUI
import SwiftSyntax

/// Generated modifier enum for OnKeyPressModifier modifiers.
///
/// This enum provides type-safe access to SwiftUI view modifiers.
/// Generated by ModifierSwift.
public enum OnKeyPressModifier: Sendable {
    case onKeyPressWithKeyEquivalentResult(SwiftUI.KeyEquivalent)
    case onKeyPressWithKeyEquivalentPhasesResult(SwiftUI.KeyEquivalent, phases: SwiftUI.KeyPress.Phases)
    case onKeyPressWithKeyEquivalentPhasesResult1(keys: Swift.Set<SwiftUI.KeyEquivalent>, phases: SwiftUI.KeyPress.Phases)
    case onKeyPressWithCharacterSetPhasesResult(characters: Foundation.CharacterSet, phases: SwiftUI.KeyPress.Phases)
    case onKeyPressWithPhasesResult(phases: SwiftUI.KeyPress.Phases)
}

extension OnKeyPressModifier: RuntimeViewModifier {
    public static var baseName: String { "onKeyPress" }

    public init(syntax: FunctionCallExprSyntax) throws {
        if syntax.arguments.count == 1 {
            if let value0 = SwiftUI.KeyEquivalent(syntax: (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil)!) {
                self = .onKeyPressWithKeyEquivalentResult(value0)
                return
            }
        }
        if syntax.arguments.count == 2 {
            if let value0 = SwiftUI.KeyEquivalent(syntax: (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil)!), let phases = SwiftUI.KeyPress.Phases(syntax: syntax.argument(named: "phases")?.expression!) {
                self = .onKeyPressWithKeyEquivalentPhasesResult(value0, phases: phases)
                return
            }
        }
        if syntax.argument(named: "keys") != nil || syntax.argument(named: "phases") != nil || syntax.argument(named: "action") != nil {
            let keys: Swift.Set<SwiftUI.KeyEquivalent> = syntax.argument(named: "keys")?.expression.flatMap { Swift.Set<SwiftUI.KeyEquivalent>(syntax: $0) }
            let phases: SwiftUI.KeyPress.Phases = syntax.argument(named: "phases")?.expression.flatMap { SwiftUI.KeyPress.Phases(syntax: $0) } ?? [.down, .repeat]
            self = .onKeyPressWithKeyEquivalentPhasesResult1(keys: keys, phases: phases)
            return
        }
        if syntax.argument(named: "characters") != nil || syntax.argument(named: "phases") != nil || syntax.argument(named: "action") != nil {
            let characters: Foundation.CharacterSet = syntax.argument(named: "characters")?.expression.flatMap { Foundation.CharacterSet(syntax: $0) }
            let phases: SwiftUI.KeyPress.Phases = syntax.argument(named: "phases")?.expression.flatMap { SwiftUI.KeyPress.Phases(syntax: $0) } ?? [.down, .repeat]
            self = .onKeyPressWithCharacterSetPhasesResult(characters: characters, phases: phases)
            return
        }
        let phases: SwiftUI.KeyPress.Phases = syntax.argument(named: "phases")?.expression.flatMap { SwiftUI.KeyPress.Phases(syntax: $0) } ?? [.down, .repeat]
        self = .onKeyPressWithPhasesResult(phases: phases)
        return
    }
    public func body(content: Content) -> some View {
        switch self {
        case .onKeyPressWithKeyEquivalentResult(let value0):
            content.onKeyPress(value0)
        case .onKeyPressWithKeyEquivalentPhasesResult(let value0, let phases):
            content.onKeyPress(value0, phases: phases)
        case .onKeyPressWithKeyEquivalentPhasesResult1(let keys, let phases):
            content.onKeyPress(keys: keys, phases: phases)
        case .onKeyPressWithCharacterSetPhasesResult(let characters, let phases):
            content.onKeyPress(characters: characters, phases: phases)
        case .onKeyPressWithPhasesResult(let phases):
            content.onKeyPress(phases: phases)
        }
    }
}