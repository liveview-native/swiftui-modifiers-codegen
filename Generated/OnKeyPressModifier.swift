import SwiftUI
import SwiftSyntax

/// Generated modifier enum for OnKeyPressModifier modifiers.
/// Generated by ModifierSwift.
public enum OnKeyPressModifier: Sendable {
    case onKeyPressWithSwiftUIKeyEquivalentescapingSwiftUIKeyPressResult(SwiftUI.KeyEquivalent, action: () -> SwiftUI.KeyPress.Result)
    case onKeyPressWithSwiftUIKeyEquivalentSwiftUIKeyPressPhasesescapingSwiftUIKeyPressSwiftUIKeyPressResult(SwiftUI.KeyEquivalent, phases: SwiftUI.KeyPress.Phases, action: (SwiftUI.KeyPress) -> SwiftUI.KeyPress.Result)
    case onKeyPressWithSwiftSetSwiftUIKeyEquivalentSwiftUIKeyPressPhasesescapingSwiftUIKeyPressSwiftUIKeyPressResult(keys: Swift.Set<SwiftUI.KeyEquivalent>, phases: SwiftUI.KeyPress.Phases, action: (SwiftUI.KeyPress) -> SwiftUI.KeyPress.Result)
    case onKeyPressWithFoundationCharacterSetSwiftUIKeyPressPhasesescapingSwiftUIKeyPressSwiftUIKeyPressResult(characters: Foundation.CharacterSet, phases: SwiftUI.KeyPress.Phases, action: (SwiftUI.KeyPress) -> SwiftUI.KeyPress.Result)
    case onKeyPressWithSwiftUIKeyPressPhasesescapingSwiftUIKeyPressSwiftUIKeyPressResult(phases: SwiftUI.KeyPress.Phases, action: (SwiftUI.KeyPress) -> SwiftUI.KeyPress.Result)
}

extension OnKeyPressModifier: RuntimeViewModifier {
    public static var baseName: String { "onKeyPress" }

    public init(syntax: FunctionCallExprSyntax) throws {
        if syntax.arguments.count == 2 {
            if let value0 = SwiftUI.KeyEquivalent(syntax: (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil)!), let action = () -> SwiftUI.KeyPress.Result(syntax: syntax.argument(named: "action")?.expression!) {
                self = .onKeyPressWithSwiftUIKeyEquivalentescapingSwiftUIKeyPressResult(value0, action: action)
                return
            }
        }
        if syntax.arguments.count == 3 {
            if let value0 = SwiftUI.KeyEquivalent(syntax: (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil)!), let phases = SwiftUI.KeyPress.Phases(syntax: syntax.argument(named: "phases")?.expression!), let action = (SwiftUI.KeyPress) -> SwiftUI.KeyPress.Result(syntax: syntax.argument(named: "action")?.expression!) {
                self = .onKeyPressWithSwiftUIKeyEquivalentSwiftUIKeyPressPhasesescapingSwiftUIKeyPressSwiftUIKeyPressResult(value0, phases: phases, action: action)
                return
            }
        }
        if syntax.argument(named: "keys") != nil || syntax.argument(named: "phases") != nil || syntax.argument(named: "action") != nil {
            let keys: Swift.Set<SwiftUI.KeyEquivalent> = syntax.argument(named: "keys")?.expression.flatMap { Swift.Set<SwiftUI.KeyEquivalent>(syntax: $0) }
            let phases: SwiftUI.KeyPress.Phases = syntax.argument(named: "phases")?.expression.flatMap { SwiftUI.KeyPress.Phases(syntax: $0) } ?? [.down, .repeat]
            let action: (SwiftUI.KeyPress) -> SwiftUI.KeyPress.Result = syntax.argument(named: "action")?.expression.flatMap { (SwiftUI.KeyPress) -> SwiftUI.KeyPress.Result(syntax: $0) }
            self = .onKeyPressWithSwiftSetSwiftUIKeyEquivalentSwiftUIKeyPressPhasesescapingSwiftUIKeyPressSwiftUIKeyPressResult(keys: keys, phases: phases, action: action)
            return
        }
        if syntax.argument(named: "characters") != nil || syntax.argument(named: "phases") != nil || syntax.argument(named: "action") != nil {
            let characters: Foundation.CharacterSet = syntax.argument(named: "characters")?.expression.flatMap { Foundation.CharacterSet(syntax: $0) }
            let phases: SwiftUI.KeyPress.Phases = syntax.argument(named: "phases")?.expression.flatMap { SwiftUI.KeyPress.Phases(syntax: $0) } ?? [.down, .repeat]
            let action: (SwiftUI.KeyPress) -> SwiftUI.KeyPress.Result = syntax.argument(named: "action")?.expression.flatMap { (SwiftUI.KeyPress) -> SwiftUI.KeyPress.Result(syntax: $0) }
            self = .onKeyPressWithFoundationCharacterSetSwiftUIKeyPressPhasesescapingSwiftUIKeyPressSwiftUIKeyPressResult(characters: characters, phases: phases, action: action)
            return
        }
        let phases: SwiftUI.KeyPress.Phases = syntax.argument(named: "phases")?.expression.flatMap { SwiftUI.KeyPress.Phases(syntax: $0) } ?? [.down, .repeat]
        let action: (SwiftUI.KeyPress) -> SwiftUI.KeyPress.Result = syntax.argument(named: "action")?.expression.flatMap { (SwiftUI.KeyPress) -> SwiftUI.KeyPress.Result(syntax: $0) }
        self = .onKeyPressWithSwiftUIKeyPressPhasesescapingSwiftUIKeyPressSwiftUIKeyPressResult(phases: phases, action: action)
        return
        throw ModifierParseError.noMatchingVariant(modifier: "OnKeyPressModifier", found: syntax.arguments.count)
    }
    public func body<Library: ElementLibrary>(content: Content, library: Library.Type) -> some View {
        switch self {
        case .onKeyPressWithSwiftUIKeyEquivalentescapingSwiftUIKeyPressResult(let value0, let action):
            content.onKeyPress(value0, action: action)
        case .onKeyPressWithSwiftUIKeyEquivalentSwiftUIKeyPressPhasesescapingSwiftUIKeyPressSwiftUIKeyPressResult(let value0, let phases, let action):
            content.onKeyPress(value0, phases: phases, action: action)
        case .onKeyPressWithSwiftSetSwiftUIKeyEquivalentSwiftUIKeyPressPhasesescapingSwiftUIKeyPressSwiftUIKeyPressResult(let keys, let phases, let action):
            content.onKeyPress(keys: keys, phases: phases, action: action)
        case .onKeyPressWithFoundationCharacterSetSwiftUIKeyPressPhasesescapingSwiftUIKeyPressSwiftUIKeyPressResult(let characters, let phases, let action):
            content.onKeyPress(characters: characters, phases: phases, action: action)
        case .onKeyPressWithSwiftUIKeyPressPhasesescapingSwiftUIKeyPressSwiftUIKeyPressResult(let phases, let action):
            content.onKeyPress(phases: phases, action: action)
        }
    }
}