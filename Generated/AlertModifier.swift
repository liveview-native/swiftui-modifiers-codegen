import SwiftUI
import SwiftSyntax

/// Generated modifier enum for AlertModifier modifiers.
///
/// This enum provides type-safe access to SwiftUI view modifiers.
/// Generated by ModifierSwift.
public enum AlertModifier: Sendable {
    case alertWithBindingItemOptionalAlert(item: SwiftUICore.Binding<Item?>)
    case alertWithBoolAlert(isPresented: SwiftUICore.Binding<Swift.Bool>)
    case alertWithLocalizedStringKeyBoolClosureAnyView(SwiftUICore.LocalizedStringKey, isPresented: SwiftUICore.Binding<Swift.Bool>)
    case alertWithLocalizedStringResourceBoolClosureAnyView(Foundation.LocalizedStringResource, isPresented: SwiftUICore.Binding<Swift.Bool>)
    case alertWithStringBoolClosureAnyView(String, isPresented: SwiftUICore.Binding<Swift.Bool>)
    case alertWithTextBoolClosureAnyView(SwiftUICore.Text, isPresented: SwiftUICore.Binding<Swift.Bool>)
    case alertWithLocalizedStringKeyBoolClosureAnyViewClosureAnyView(SwiftUICore.LocalizedStringKey, isPresented: SwiftUICore.Binding<Swift.Bool>)
    case alertWithLocalizedStringResourceBoolClosureAnyViewClosureAnyView(Foundation.LocalizedStringResource, isPresented: SwiftUICore.Binding<Swift.Bool>)
    case alertWithStringBoolClosureAnyViewClosureAnyView(String, isPresented: SwiftUICore.Binding<Swift.Bool>)
    case alertWithTextBoolClosureAnyViewClosureAnyView(SwiftUICore.Text, isPresented: SwiftUICore.Binding<Swift.Bool>)
    case alertWithLocalizedStringKeyBoolTOptionalClosureAnyView(SwiftUICore.LocalizedStringKey, isPresented: SwiftUICore.Binding<Swift.Bool>, presenting: T?)
    case alertWithLocalizedStringResourceBoolTOptionalClosureAnyView(Foundation.LocalizedStringResource, isPresented: SwiftUICore.Binding<Swift.Bool>, presenting: T?)
    case alertWithStringBoolTOptionalClosureAnyView(String, isPresented: SwiftUICore.Binding<Swift.Bool>, presenting: T?)
    case alertWithTextBoolTOptionalClosureAnyView(SwiftUICore.Text, isPresented: SwiftUICore.Binding<Swift.Bool>, presenting: T?)
    case alertWithLocalizedStringKeyBoolTOptionalClosureAnyViewClosureAnyView(SwiftUICore.LocalizedStringKey, isPresented: SwiftUICore.Binding<Swift.Bool>, presenting: T?)
    case alertWithLocalizedStringResourceBoolTOptionalClosureAnyViewClosureAnyView(Foundation.LocalizedStringResource, isPresented: SwiftUICore.Binding<Swift.Bool>, presenting: T?)
    case alertWithStringBoolTOptionalClosureAnyViewClosureAnyView(String, isPresented: SwiftUICore.Binding<Swift.Bool>, presenting: T?)
    case alertWithTextBoolTOptionalClosureAnyViewClosureAnyView(SwiftUICore.Text, isPresented: SwiftUICore.Binding<Swift.Bool>, presenting: T?)
    case alertWithBoolEOptionalClosureAnyView(isPresented: SwiftUICore.Binding<Swift.Bool>, error: E?)
    case alertWithBoolEOptionalClosureAnyViewClosureAnyView(isPresented: SwiftUICore.Binding<Swift.Bool>, error: E?)
}

extension AlertModifier: RuntimeViewModifier {
    public static var baseName: String { "alert" }

    public init(syntax: FunctionCallExprSyntax) throws {
        switch syntax.arguments.count {
        case 1:
            let firstLabel = syntax.arguments.first?.label?.text
            switch firstLabel {
            case "isPresented":
                guard let expr_isPresented = syntax.argument(named: "isPresented")?.expression, let isPresented = SwiftUICore.Binding<Swift.Bool>(syntax: expr_isPresented) else {
                    throw ModifierParseError.invalidArguments(modifier: "AlertModifier", variant: "alertWithBoolAlert", expectedTypes: "SwiftUICore.Binding<Swift.Bool>")
                }
                self = .alertWithBoolAlert(isPresented: isPresented)
            case "item":
                guard let expr_item = syntax.argument(named: "item")?.expression, let item = SwiftUICore.Binding<Item?>(syntax: expr_item) else {
                    throw ModifierParseError.invalidArguments(modifier: "AlertModifier", variant: "alertWithBindingItemOptionalAlert", expectedTypes: "SwiftUICore.Binding<Item?>")
                }
                self = .alertWithBindingItemOptionalAlert(item: item)
            default:
                throw ModifierParseError.ambiguousVariant(modifier: "AlertModifier", expectedLabels: ["item", "isPresented"])
            }
        case 2:
            let firstLabel = syntax.arguments.first?.label?.text
            switch firstLabel {
            case nil:
                if let value0: SwiftUICore.LocalizedStringKey = SwiftUICore.LocalizedStringKey(syntax: (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil)!), let expr_isPresented = syntax.argument(named: "isPresented")?.expression, let isPresented = SwiftUICore.Binding<Swift.Bool>(syntax: expr_isPresented) {
                    self = .alertWithLocalizedStringKeyBoolClosureAnyView(value0, isPresented: isPresented)
                } else if let value0: Foundation.LocalizedStringResource = Foundation.LocalizedStringResource(syntax: (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil)!), let expr_isPresented = syntax.argument(named: "isPresented")?.expression, let isPresented = SwiftUICore.Binding<Swift.Bool>(syntax: expr_isPresented) {
                    self = .alertWithLocalizedStringResourceBoolClosureAnyView(value0, isPresented: isPresented)
                } else if let value0: String = String(syntax: (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil)!), let expr_isPresented = syntax.argument(named: "isPresented")?.expression, let isPresented = SwiftUICore.Binding<Swift.Bool>(syntax: expr_isPresented) {
                    self = .alertWithStringBoolClosureAnyView(value0, isPresented: isPresented)
                } else if let value0: SwiftUICore.Text = SwiftUICore.Text(syntax: (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil)!), let expr_isPresented = syntax.argument(named: "isPresented")?.expression, let isPresented = SwiftUICore.Binding<Swift.Bool>(syntax: expr_isPresented) {
                    self = .alertWithTextBoolClosureAnyView(value0, isPresented: isPresented)
                } else if let value0: SwiftUICore.LocalizedStringKey = SwiftUICore.LocalizedStringKey(syntax: (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil)!), let expr_isPresented = syntax.argument(named: "isPresented")?.expression, let isPresented = SwiftUICore.Binding<Swift.Bool>(syntax: expr_isPresented) {
                    self = .alertWithLocalizedStringKeyBoolClosureAnyViewClosureAnyView(value0, isPresented: isPresented)
                } else if let value0: Foundation.LocalizedStringResource = Foundation.LocalizedStringResource(syntax: (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil)!), let expr_isPresented = syntax.argument(named: "isPresented")?.expression, let isPresented = SwiftUICore.Binding<Swift.Bool>(syntax: expr_isPresented) {
                    self = .alertWithLocalizedStringResourceBoolClosureAnyViewClosureAnyView(value0, isPresented: isPresented)
                } else if let value0: String = String(syntax: (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil)!), let expr_isPresented = syntax.argument(named: "isPresented")?.expression, let isPresented = SwiftUICore.Binding<Swift.Bool>(syntax: expr_isPresented) {
                    self = .alertWithStringBoolClosureAnyViewClosureAnyView(value0, isPresented: isPresented)
                } else if let value0: SwiftUICore.Text = SwiftUICore.Text(syntax: (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil)!), let expr_isPresented = syntax.argument(named: "isPresented")?.expression, let isPresented = SwiftUICore.Binding<Swift.Bool>(syntax: expr_isPresented) {
                    self = .alertWithTextBoolClosureAnyViewClosureAnyView(value0, isPresented: isPresented)
                } else {
                    throw ModifierParseError.invalidArguments(modifier: "AlertModifier", variant: "multiple variants", expectedTypes: "SwiftUICore.LocalizedStringKey, SwiftUICore.Binding<Swift.Bool> or Foundation.LocalizedStringResource, SwiftUICore.Binding<Swift.Bool> or String, SwiftUICore.Binding<Swift.Bool> or SwiftUICore.Text, SwiftUICore.Binding<Swift.Bool> or SwiftUICore.LocalizedStringKey, SwiftUICore.Binding<Swift.Bool> or Foundation.LocalizedStringResource, SwiftUICore.Binding<Swift.Bool> or String, SwiftUICore.Binding<Swift.Bool> or SwiftUICore.Text, SwiftUICore.Binding<Swift.Bool>")
                }
            case "isPresented":
                if let expr_isPresented = syntax.argument(named: "isPresented")?.expression, let isPresented = SwiftUICore.Binding<Swift.Bool>(syntax: expr_isPresented) {
                    let error: E = if let expr = syntax.argument(named: "error")?.expression { E(syntax: expr) } else { nil }
                    self = .alertWithBoolEOptionalClosureAnyView(isPresented: isPresented, error: error)
                } else if let expr_isPresented = syntax.argument(named: "isPresented")?.expression, let isPresented = SwiftUICore.Binding<Swift.Bool>(syntax: expr_isPresented) {
                    let error: E = if let expr = syntax.argument(named: "error")?.expression { E(syntax: expr) } else { nil }
                    self = .alertWithBoolEOptionalClosureAnyViewClosureAnyView(isPresented: isPresented, error: error)
                } else {
                    throw ModifierParseError.invalidArguments(modifier: "AlertModifier", variant: "multiple variants", expectedTypes: "SwiftUICore.Binding<Swift.Bool>, E? or SwiftUICore.Binding<Swift.Bool>, E?")
                }
            default:
                throw ModifierParseError.ambiguousVariant(modifier: "AlertModifier", expectedLabels: ["isPresented"])
            }
        case 3:
            if let value0: SwiftUICore.LocalizedStringKey = SwiftUICore.LocalizedStringKey(syntax: (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil)!), let expr_isPresented = syntax.argument(named: "isPresented")?.expression, let isPresented = SwiftUICore.Binding<Swift.Bool>(syntax: expr_isPresented) {
                let presenting: T = if let expr = syntax.argument(named: "presenting")?.expression { T(syntax: expr) } else { nil }
                self = .alertWithLocalizedStringKeyBoolTOptionalClosureAnyView(value0, isPresented: isPresented, presenting: presenting)
            } else if let value0: Foundation.LocalizedStringResource = Foundation.LocalizedStringResource(syntax: (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil)!), let expr_isPresented = syntax.argument(named: "isPresented")?.expression, let isPresented = SwiftUICore.Binding<Swift.Bool>(syntax: expr_isPresented) {
                let presenting: T = if let expr = syntax.argument(named: "presenting")?.expression { T(syntax: expr) } else { nil }
                self = .alertWithLocalizedStringResourceBoolTOptionalClosureAnyView(value0, isPresented: isPresented, presenting: presenting)
            } else if let value0: String = String(syntax: (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil)!), let expr_isPresented = syntax.argument(named: "isPresented")?.expression, let isPresented = SwiftUICore.Binding<Swift.Bool>(syntax: expr_isPresented) {
                let presenting: T = if let expr = syntax.argument(named: "presenting")?.expression { T(syntax: expr) } else { nil }
                self = .alertWithStringBoolTOptionalClosureAnyView(value0, isPresented: isPresented, presenting: presenting)
            } else if let value0: SwiftUICore.Text = SwiftUICore.Text(syntax: (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil)!), let expr_isPresented = syntax.argument(named: "isPresented")?.expression, let isPresented = SwiftUICore.Binding<Swift.Bool>(syntax: expr_isPresented) {
                let presenting: T = if let expr = syntax.argument(named: "presenting")?.expression { T(syntax: expr) } else { nil }
                self = .alertWithTextBoolTOptionalClosureAnyView(value0, isPresented: isPresented, presenting: presenting)
            } else if let value0: SwiftUICore.LocalizedStringKey = SwiftUICore.LocalizedStringKey(syntax: (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil)!), let expr_isPresented = syntax.argument(named: "isPresented")?.expression, let isPresented = SwiftUICore.Binding<Swift.Bool>(syntax: expr_isPresented) {
                let presenting: T = if let expr = syntax.argument(named: "presenting")?.expression { T(syntax: expr) } else { nil }
                self = .alertWithLocalizedStringKeyBoolTOptionalClosureAnyViewClosureAnyView(value0, isPresented: isPresented, presenting: presenting)
            } else if let value0: Foundation.LocalizedStringResource = Foundation.LocalizedStringResource(syntax: (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil)!), let expr_isPresented = syntax.argument(named: "isPresented")?.expression, let isPresented = SwiftUICore.Binding<Swift.Bool>(syntax: expr_isPresented) {
                let presenting: T = if let expr = syntax.argument(named: "presenting")?.expression { T(syntax: expr) } else { nil }
                self = .alertWithLocalizedStringResourceBoolTOptionalClosureAnyViewClosureAnyView(value0, isPresented: isPresented, presenting: presenting)
            } else if let value0: String = String(syntax: (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil)!), let expr_isPresented = syntax.argument(named: "isPresented")?.expression, let isPresented = SwiftUICore.Binding<Swift.Bool>(syntax: expr_isPresented) {
                let presenting: T = if let expr = syntax.argument(named: "presenting")?.expression { T(syntax: expr) } else { nil }
                self = .alertWithStringBoolTOptionalClosureAnyViewClosureAnyView(value0, isPresented: isPresented, presenting: presenting)
            } else if let value0: SwiftUICore.Text = SwiftUICore.Text(syntax: (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil)!), let expr_isPresented = syntax.argument(named: "isPresented")?.expression, let isPresented = SwiftUICore.Binding<Swift.Bool>(syntax: expr_isPresented) {
                let presenting: T = if let expr = syntax.argument(named: "presenting")?.expression { T(syntax: expr) } else { nil }
                self = .alertWithTextBoolTOptionalClosureAnyViewClosureAnyView(value0, isPresented: isPresented, presenting: presenting)
            } else {
                throw ModifierParseError.invalidArguments(modifier: "AlertModifier", variant: "multiple variants", expectedTypes: "SwiftUICore.LocalizedStringKey, SwiftUICore.Binding<Swift.Bool>, T? or Foundation.LocalizedStringResource, SwiftUICore.Binding<Swift.Bool>, T? or String, SwiftUICore.Binding<Swift.Bool>, T? or SwiftUICore.Text, SwiftUICore.Binding<Swift.Bool>, T? or SwiftUICore.LocalizedStringKey, SwiftUICore.Binding<Swift.Bool>, T? or Foundation.LocalizedStringResource, SwiftUICore.Binding<Swift.Bool>, T? or String, SwiftUICore.Binding<Swift.Bool>, T? or SwiftUICore.Text, SwiftUICore.Binding<Swift.Bool>, T?")
            }
        default:
            throw ModifierParseError.unexpectedArgumentCount(modifier: "AlertModifier", expected: [1, 2, 3], found: syntax.arguments.count)
        }
    }

    public func body(content: Content) -> some View {
        switch self {
        case .alertWithBindingItemOptionalAlert(let item):
            content.alert(item: item)
        case .alertWithBoolAlert(let isPresented):
            content.alert(isPresented: isPresented)
        case .alertWithLocalizedStringKeyBoolClosureAnyView(let value0, let isPresented):
            content.alert(value0, isPresented: isPresented)
        case .alertWithLocalizedStringResourceBoolClosureAnyView(let value0, let isPresented):
            content.alert(value0, isPresented: isPresented)
        case .alertWithStringBoolClosureAnyView(let value0, let isPresented):
            content.alert(value0, isPresented: isPresented)
        case .alertWithTextBoolClosureAnyView(let value0, let isPresented):
            content.alert(value0, isPresented: isPresented)
        case .alertWithLocalizedStringKeyBoolClosureAnyViewClosureAnyView(let value0, let isPresented):
            content.alert(value0, isPresented: isPresented)
        case .alertWithLocalizedStringResourceBoolClosureAnyViewClosureAnyView(let value0, let isPresented):
            content.alert(value0, isPresented: isPresented)
        case .alertWithStringBoolClosureAnyViewClosureAnyView(let value0, let isPresented):
            content.alert(value0, isPresented: isPresented)
        case .alertWithTextBoolClosureAnyViewClosureAnyView(let value0, let isPresented):
            content.alert(value0, isPresented: isPresented)
        case .alertWithLocalizedStringKeyBoolTOptionalClosureAnyView(let value0, let isPresented, let presenting):
            content.alert(value0, isPresented: isPresented, presenting: presenting)
        case .alertWithLocalizedStringResourceBoolTOptionalClosureAnyView(let value0, let isPresented, let presenting):
            content.alert(value0, isPresented: isPresented, presenting: presenting)
        case .alertWithStringBoolTOptionalClosureAnyView(let value0, let isPresented, let presenting):
            content.alert(value0, isPresented: isPresented, presenting: presenting)
        case .alertWithTextBoolTOptionalClosureAnyView(let value0, let isPresented, let presenting):
            content.alert(value0, isPresented: isPresented, presenting: presenting)
        case .alertWithLocalizedStringKeyBoolTOptionalClosureAnyViewClosureAnyView(let value0, let isPresented, let presenting):
            content.alert(value0, isPresented: isPresented, presenting: presenting)
        case .alertWithLocalizedStringResourceBoolTOptionalClosureAnyViewClosureAnyView(let value0, let isPresented, let presenting):
            content.alert(value0, isPresented: isPresented, presenting: presenting)
        case .alertWithStringBoolTOptionalClosureAnyViewClosureAnyView(let value0, let isPresented, let presenting):
            content.alert(value0, isPresented: isPresented, presenting: presenting)
        case .alertWithTextBoolTOptionalClosureAnyViewClosureAnyView(let value0, let isPresented, let presenting):
            content.alert(value0, isPresented: isPresented, presenting: presenting)
        case .alertWithBoolEOptionalClosureAnyView(let isPresented, let error):
            content.alert(isPresented: isPresented, error: error)
        case .alertWithBoolEOptionalClosureAnyViewClosureAnyView(let isPresented, let error):
            content.alert(isPresented: isPresented, error: error)
        }
    }
}