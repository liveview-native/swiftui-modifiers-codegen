import SwiftUI
import SwiftSyntax

/// Generated modifier enum for OnTapGestureModifier modifiers.
/// Generated by ModifierSwift.
public enum OnTapGestureModifier: Sendable {
    case onTapGestureWithSwiftIntSwiftUICoreCoordinateSpaceescapingCoreFoundationCGPointSwiftVoid(count: Swift.Int, coordinateSpace: SwiftUICore.CoordinateSpace, perform: (CoreFoundation.CGPoint) -> Swift.Void)
    case onTapGestureWithSwiftIntsomeCoordinateSpaceProtocolescapingCoreFoundationCGPointSwiftVoid(count: Swift.Int, coordinateSpace: some CoordinateSpaceProtocol, perform: (CoreFoundation.CGPoint) -> Swift.Void)
    case onTapGestureWithSwiftIntescapingSwiftVoid(count: Swift.Int, perform: () -> Swift.Void)
}

extension OnTapGestureModifier: RuntimeViewModifier {
    public static var baseName: String { "onTapGesture" }

    public init(syntax: FunctionCallExprSyntax) throws {
        if syntax.argument(named: "count") != nil || syntax.argument(named: "coordinateSpace") != nil || syntax.argument(named: "perform") != nil {
            let count: Swift.Int = syntax.argument(named: "count")?.expression.flatMap { Swift.Int(syntax: $0) } ?? 1
            let coordinateSpace: SwiftUICore.CoordinateSpace = syntax.argument(named: "coordinateSpace")?.expression.flatMap { SwiftUICore.CoordinateSpace(syntax: $0) } ?? .local
            let perform: (CoreFoundation.CGPoint) -> Swift.Void = syntax.argument(named: "perform")?.expression.flatMap { (CoreFoundation.CGPoint) -> Swift.Void(syntax: $0) }
            self = .onTapGestureWithSwiftIntSwiftUICoreCoordinateSpaceescapingCoreFoundationCGPointSwiftVoid(count: count, coordinateSpace: coordinateSpace, perform: perform)
            return
        }
        if syntax.argument(named: "count") != nil || syntax.argument(named: "coordinateSpace") != nil || syntax.argument(named: "perform") != nil {
            let count: Swift.Int = syntax.argument(named: "count")?.expression.flatMap { Swift.Int(syntax: $0) } ?? 1
            let coordinateSpace: some CoordinateSpaceProtocol = syntax.argument(named: "coordinateSpace")?.expression.flatMap { some CoordinateSpaceProtocol(syntax: $0) } ?? .local
            let perform: (CoreFoundation.CGPoint) -> Swift.Void = syntax.argument(named: "perform")?.expression.flatMap { (CoreFoundation.CGPoint) -> Swift.Void(syntax: $0) }
            self = .onTapGestureWithSwiftIntsomeCoordinateSpaceProtocolescapingCoreFoundationCGPointSwiftVoid(count: count, coordinateSpace: coordinateSpace, perform: perform)
            return
        }
        let count: Swift.Int = syntax.argument(named: "count")?.expression.flatMap { Swift.Int(syntax: $0) } ?? 1
        let perform: () -> Swift.Void = syntax.argument(named: "perform")?.expression.flatMap { () -> Swift.Void(syntax: $0) }
        self = .onTapGestureWithSwiftIntescapingSwiftVoid(count: count, perform: perform)
        return
        throw ModifierParseError.noMatchingVariant(modifier: "OnTapGestureModifier", found: syntax.arguments.count)
    }
    public func body<Library: ElementLibrary>(content: Content, library: Library.Type) -> some View {
        switch self {
        case .onTapGestureWithSwiftIntSwiftUICoreCoordinateSpaceescapingCoreFoundationCGPointSwiftVoid(let count, let coordinateSpace, let perform):
            content.onTapGesture(count: count, coordinateSpace: coordinateSpace, perform: perform)
        case .onTapGestureWithSwiftIntsomeCoordinateSpaceProtocolescapingCoreFoundationCGPointSwiftVoid(let count, let coordinateSpace, let perform):
            content.onTapGesture(count: count, coordinateSpace: coordinateSpace, perform: perform)
        case .onTapGestureWithSwiftIntescapingSwiftVoid(let count, let perform):
            content.onTapGesture(count: count, perform: perform)
        }
    }
}