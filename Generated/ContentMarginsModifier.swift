import SwiftUI
import SwiftSyntax

/// Generated modifier enum for ContentMarginsModifier modifiers.
/// Generated by ModifierSwift.
public enum ContentMarginsModifier: Sendable {
    case contentMarginsWithSwiftUICoreEdgeSetSwiftUICoreEdgeInsetsSwiftUIContentMarginPlacement(SwiftUICore.Edge.Set, SwiftUICore.EdgeInsets, for: SwiftUI.ContentMarginPlacement)
    case contentMarginsWithSwiftUICoreEdgeSetCoreFoundationCGFloatOptionalSwiftUIContentMarginPlacement(SwiftUICore.Edge.Set, CoreFoundation.CGFloat?, for: SwiftUI.ContentMarginPlacement)
    case contentMarginsWithCoreFoundationCGFloatSwiftUIContentMarginPlacement(CoreFoundation.CGFloat, for: SwiftUI.ContentMarginPlacement)
}

extension ContentMarginsModifier: RuntimeViewModifier {
    public static var baseName: String { "contentMargins" }

    public init(syntax: FunctionCallExprSyntax) throws {
        if syntax.argument(named: "for") != nil {
            let value0: SwiftUICore.Edge.Set = (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil).flatMap { SwiftUICore.Edge.Set(syntax: $0) } ?? .all
            let value1: SwiftUICore.EdgeInsets = (syntax.arguments.count > 1 ? syntax.arguments[1].expression : nil).flatMap { SwiftUICore.EdgeInsets(syntax: $0) }
            let for: SwiftUI.ContentMarginPlacement = syntax.argument(named: "for")?.expression.flatMap { SwiftUI.ContentMarginPlacement(syntax: $0) } ?? .automatic
            self = .contentMarginsWithSwiftUICoreEdgeSetSwiftUICoreEdgeInsetsSwiftUIContentMarginPlacement(value0, value1, for: for)
            return
        }
        if syntax.argument(named: "for") != nil {
            let value0: SwiftUICore.Edge.Set = (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil).flatMap { SwiftUICore.Edge.Set(syntax: $0) } ?? .all
            let value1: CoreFoundation.CGFloat? = (syntax.arguments.count > 1 ? syntax.arguments[1].expression : nil).flatMap { CoreFoundation.CGFloat(syntax: $0) } ?? nil
            let for: SwiftUI.ContentMarginPlacement = syntax.argument(named: "for")?.expression.flatMap { SwiftUI.ContentMarginPlacement(syntax: $0) } ?? .automatic
            self = .contentMarginsWithSwiftUICoreEdgeSetCoreFoundationCGFloatOptionalSwiftUIContentMarginPlacement(value0, value1, for: for)
            return
        }
        let value0: CoreFoundation.CGFloat = (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil).flatMap { CoreFoundation.CGFloat(syntax: $0) }
        let for: SwiftUI.ContentMarginPlacement = syntax.argument(named: "for")?.expression.flatMap { SwiftUI.ContentMarginPlacement(syntax: $0) } ?? .automatic
        self = .contentMarginsWithCoreFoundationCGFloatSwiftUIContentMarginPlacement(value0, for: for)
        return
        throw ModifierParseError.noMatchingVariant(modifier: "ContentMarginsModifier", found: syntax.arguments.count)
    }
    public func body<Library: ElementLibrary>(content: Content, library: Library.Type) -> some View {
        switch self {
        case .contentMarginsWithSwiftUICoreEdgeSetSwiftUICoreEdgeInsetsSwiftUIContentMarginPlacement(let value0, let value1, let for):
            content.contentMargins(value0, value1, for: for)
        case .contentMarginsWithSwiftUICoreEdgeSetCoreFoundationCGFloatOptionalSwiftUIContentMarginPlacement(let value0, let value1, let for):
            content.contentMargins(value0, value1, for: for)
        case .contentMarginsWithCoreFoundationCGFloatSwiftUIContentMarginPlacement(let value0, let for):
            content.contentMargins(value0, for: for)
        }
    }
}