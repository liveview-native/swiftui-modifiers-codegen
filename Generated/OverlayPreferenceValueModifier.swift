import SwiftUI
import SwiftSyntax

/// Generated modifier enum for OverlayPreferenceValueModifier modifiers.
///
/// This enum provides type-safe access to SwiftUI view modifiers.
/// Generated by ModifierSwift.
public enum OverlayPreferenceValueModifier: Sendable {
    case overlayPreferenceValueWithTypeAlignmentClosureAnyView(K.Type, alignment: SwiftUICore.Alignment)
    case overlayPreferenceValueWithVoidTypeAlignmentClosureAnyView(_v0: Swift.Void, K.Type, alignment: SwiftUICore.Alignment)
    case overlayPreferenceValueWithTypeClosureAnyView(Key.Type)
}

extension OverlayPreferenceValueModifier: RuntimeViewModifier {
    public static var baseName: String { "overlayPreferenceValue" }

    public init(syntax: FunctionCallExprSyntax) throws {
        switch syntax.arguments.count {
        case 1:
            let value0: Key.Type = if let expr = (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil), let parsed = Key.Type(syntax: expr) { parsed } else { Key.self }
            self = .overlayPreferenceValueWithTypeClosureAnyView(value0)
        case 2:
            guard let expr_value0 = (syntax.arguments.count > 0 ? syntax.arguments[0].expression : nil), let value0 = K.Type(syntax: expr_value0) else {
                throw ModifierParseError.invalidArguments(modifier: "OverlayPreferenceValueModifier", variant: "overlayPreferenceValueWithTypeAlignmentClosureAnyView", expectedTypes: "K.Type, SwiftUICore.Alignment")
            }
            let alignment: SwiftUICore.Alignment = if let expr = syntax.argument(named: "alignment")?.expression, let parsed = SwiftUICore.Alignment(syntax: expr) { parsed } else { .center }
            self = .overlayPreferenceValueWithTypeAlignmentClosureAnyView(value0, alignment: alignment)
        case 3:
            let _v0: Swift.Void = if let expr = syntax.argument(named: "_v0")?.expression, let parsed = Swift.Void(syntax: expr) { parsed } else { () }
            guard let expr_value1 = (syntax.arguments.count > 1 ? syntax.arguments[1].expression : nil), let value1 = K.Type(syntax: expr_value1) else {
                throw ModifierParseError.invalidArguments(modifier: "OverlayPreferenceValueModifier", variant: "overlayPreferenceValueWithVoidTypeAlignmentClosureAnyView", expectedTypes: "Swift.Void, K.Type, SwiftUICore.Alignment")
            }
            guard let expr_alignment = syntax.argument(named: "alignment")?.expression, let alignment = SwiftUICore.Alignment(syntax: expr_alignment) else {
                throw ModifierParseError.invalidArguments(modifier: "OverlayPreferenceValueModifier", variant: "overlayPreferenceValueWithVoidTypeAlignmentClosureAnyView", expectedTypes: "Swift.Void, K.Type, SwiftUICore.Alignment")
            }
            self = .overlayPreferenceValueWithVoidTypeAlignmentClosureAnyView(_v0: _v0, value1, alignment: alignment)
        default:
            throw ModifierParseError.unexpectedArgumentCount(modifier: "OverlayPreferenceValueModifier", expected: [1, 2, 3], found: syntax.arguments.count)
        }
    }

    public func body(content: Content) -> some View {
        switch self {
        case .overlayPreferenceValueWithTypeAlignmentClosureAnyView(let value0, let alignment):
            content.overlayPreferenceValue(value0, alignment: alignment)
        case .overlayPreferenceValueWithVoidTypeAlignmentClosureAnyView(let _v0, let value1, let alignment):
            content.overlayPreferenceValue(_v0: _v0, value1, alignment: alignment)
        case .overlayPreferenceValueWithTypeClosureAnyView(let value0):
            content.overlayPreferenceValue(value0)
        }
    }
}