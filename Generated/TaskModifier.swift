import SwiftUI
import SwiftSyntax

/// Generated modifier enum for TaskModifier modifiers.
/// Generated by ModifierSwift.
public enum TaskModifier: Sendable {
    case taskWithConcurrencyTaskPriorityescapingSendableasyncSwiftVoid(priority: _Concurrency.TaskPriority, @Sendable () async -> Swift.Void)
    case taskWithTConcurrencyTaskPriorityescapingSendableasyncSwiftVoid(id: T, priority: _Concurrency.TaskPriority, @Sendable () async -> Swift.Void)
}

extension TaskModifier: RuntimeViewModifier {
    public static var baseName: String { "task" }

    public init(syntax: FunctionCallExprSyntax) throws {
        if syntax.argument(named: "priority") != nil {
            let priority: _Concurrency.TaskPriority = syntax.argument(named: "priority")?.expression.flatMap { _Concurrency.TaskPriority(syntax: $0) } ?? .userInitiated
            let value1: @Sendable () async -> Swift.Void = (syntax.arguments.count > 1 ? syntax.arguments[1].expression : nil).flatMap { @Sendable () async -> Swift.Void(syntax: $0) }
            self = .taskWithConcurrencyTaskPriorityescapingSendableasyncSwiftVoid(priority: priority, value1)
            return
        }
        let id: T = syntax.argument(named: "id")?.expression.flatMap { T(syntax: $0) }
        let priority: _Concurrency.TaskPriority = syntax.argument(named: "priority")?.expression.flatMap { _Concurrency.TaskPriority(syntax: $0) } ?? .userInitiated
        let value2: @Sendable () async -> Swift.Void = (syntax.arguments.count > 2 ? syntax.arguments[2].expression : nil).flatMap { @Sendable () async -> Swift.Void(syntax: $0) }
        self = .taskWithTConcurrencyTaskPriorityescapingSendableasyncSwiftVoid(id: id, priority: priority, value2)
        return
        throw ModifierParseError.noMatchingVariant(modifier: "TaskModifier", found: syntax.arguments.count)
    }
    public func body<Library: ElementLibrary>(content: Content, library: Library.Type) -> some View {
        switch self {
        case .taskWithConcurrencyTaskPriorityescapingSendableasyncSwiftVoid(let priority, let value1):
            content.task(priority: priority, value1)
        case .taskWithTConcurrencyTaskPriorityescapingSendableasyncSwiftVoid(let id, let priority, let value2):
            content.task(id: id, priority: priority, value2)
        }
    }
}